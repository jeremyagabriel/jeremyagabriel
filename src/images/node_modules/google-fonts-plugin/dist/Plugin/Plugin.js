"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const webpack_sources_1 = require("webpack-sources");
const Chunk_1 = require("../Chunk/Chunk");
const Fonts_1 = require("../Fonts/Fonts");
const Options_1 = require("../Options/Options");
const Stats_1 = require("../Stats/Stats");
class Plugin {
    constructor(input) {
        this.getFilename = (format, compilation) => {
            let { filename } = this.options;
            const replaceMatrix = {
                name: format,
                hash: compilation.hash || '',
                chunkhash: Chunk_1.default.hash(this.options)
            };
            for (const key of Object.keys(replaceMatrix)) {
                const regex = new RegExp(`\\[${key}:?(\\d+)?\\]`, 'gi');
                const result = regex.exec(filename);
                if (result) {
                    filename = filename.replace(regex, replaceMatrix[key].substring(0, result[1] ? Number(result[1]) : Infinity));
                }
            }
            return filename;
        };
        this.apply = (compiler) => {
            compiler.hooks.environment.tap(Plugin.getPluginName(), this.options.get);
            compiler.hooks.watchRun.tap(Plugin.getPluginName(), this.options.get);
            compiler.hooks.make.tapAsync(Plugin.getPluginName(), async (compilation, callback) => {
                const chunk = new Chunk_1.default(compilation, this.options.chunkName);
                chunk.create();
                for (const format of Object.values(this.options.formats)) {
                    const fonts = new Fonts_1.default(format, this.options);
                    let css = await fonts.requestFontsCSS();
                    css = await fonts.encode(css);
                    compilation.assets[`${format}.css`] = new webpack_sources_1.RawSource(css);
                }
                compilation.hooks.chunkHash.tap(Plugin.getPluginName(), (chunk, chunkHash) => {
                    if (chunk.name === this.options.chunkName) {
                        chunkHash.digest = () => Chunk_1.default.hash(this.options.get());
                    }
                });
                callback();
            });
            compiler.hooks.afterCompile.tap(Plugin.getPluginName(), (compilation) => {
                compilation.contextDependencies.add(this.options.file);
            });
            compiler.hooks.emit.tap(Plugin.getPluginName(), (compilation) => {
                const chunk = new Chunk_1.default(compilation, this.options.chunkName).get();
                delete compilation.assets[chunk.files[0]];
                for (const format of Object.values(this.options.formats)) {
                    const file = this.getFilename(format, compilation);
                    chunk.files.push(file);
                    if (file !== `${format}.css`) {
                        compilation.assets[file] = new webpack_sources_1.RawSource(compilation.assets[`${format}.css`].source());
                        delete compilation.assets[`${format}.css`];
                    }
                }
            });
        };
        this.options = new Options_1.default(input);
        if (this.options.stats) {
            new Stats_1.default().track(this.options);
        }
    }
}
exports.default = Plugin;
Plugin.pluginName = 'google-fonts-plugin';
Plugin.getPluginName = () => Plugin.pluginName;
//# sourceMappingURL=Plugin.js.map